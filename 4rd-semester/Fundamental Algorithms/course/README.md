## Техническое задание
  Разработайте приложение для проведения лотереи формата “спортлото” (5 из 36, 6 из 49 и т. п.). 
Ваше приложение должно обеспечивать генерацию билетов для очередного тиража лотереи (генератор должен быть реализован посредством паттерна “фабричный метод”). Количество генерируемых билетов произвольно и 
может быть велико (> 20’000’000 шт.). Учтите ситуацию, что не все сгенерированные билеты могут участвовать 
в тираже (это типичная ситуация, которая возникает при неполной реализации билетов к тиражу). Смоделируйте проведение розыгрыша: на каждом ходе проверяйте, появился ли победитель; предусмотрите систему выигрышей; предоставьте возможность поиска билетов по заданным критериям: номеру билета, величине выигрыша, 
и т. д.. Сохраняйте информацию о проведенных тиражах для обеспечения поиска данных в будущем. 
Реализуйте функционал обработки данных таким образом, чтобы тип коллекции, в которой будут храниться ваши данные, являлся параметром. Продемонстрируйте обработку данных с использованием std::vector и собственной реализации двусвязного списка.

***

## Алгоритм работы ПО
1. Создание БД для далейней работы тиражного аппарата.
2. Запуск ПО для эмуляции купленных билетов.
3. Анализ построенной БД для распределения выйгрышей и составления статистики

***

## Необходимые модули
### Эмулятор распродажи билетов
Для каждого билета случайным образом генерируется от 4 до 7 чисел, которые заносятся в БД вместе с id

### База данных
Первым уровнем базы данных являются папки лотерей (предварительно 4 шт)
Следующий уровень - папки с тиражами (отсчет с 1)
В каждой папке тиража распределены файлы с элементами (Приложение json-билеты) 

***

## Приложение
### json-билеты
``` 
{
    "id" : int, 
    "numbers" : [[int, int, int, ...], [int]], # размерность массива определяется типом лотыреи
    "sale" : True
    "winning" : int     # выигрыш билета 
}
```
  // uint64_t time2;
  // time2 = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now()-start).count();
  // auto start = std::chrono::high_resolution_clock::now();
  // std::cout << "Time = " << time2 << " || " << std::endl;
